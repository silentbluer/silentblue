## 1、变量
JavaScript变量是松散型,可以存储任意类型的数据。变量只不过是一个用来存储任意值的命名占位符。有三个关键词可以声明变量:var,let,const。其中，var可以在ECMAScript的所有版本中使用，而let和const只能用于ECMAScript6及之后的版本中。
***
### 1.1 var关键字
#### 1.1.1 var声明作用域
使用var操作符定义的变量会成为包含它的函数的局部变量，该变量在函数退出时销毁。**在函数定义变量时省略var操作符，可以定义一个全局变量**。var声明会在函数执行前创建并将其初始化为undefined。
> 不推荐这么做，局部作用域中定义的全局变量很难维护，而且无法确定是否有意如此。在<u>***"use strict"***</u>模式下，给未声明的变量赋值会抛出ReferenceError；也不能定义名为eval和arguments的变量，否则会导致语法错误。
#### 1.1.2 var声明提升
var定义的变量会自动提升到函数作用域顶部，反复多次使用var声明一个变量，会按照声明顺序倒叙提升到函数作用域顶部。
### 1.2 let声明
#### 1.2.1 let声明作用域
* let声明的范围是函数内部的块作用域，而var声明的作用范围是函数作用域。块作用域是函数作用域的子集，因此，适用于var的作用域限制也适用于let。
* let不允许一个块作用域中出现冗余声明，会报syntaxError。对于let和var混用的声明也会抛出syntaxError，因为他们声明的是同类型的变量，只是指出相关变量如何在作用域存在。
* JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域，因此，嵌套使用相同的标识符不会报错，这是因为同一个块中没有重复声明。
#### 1.2.2暂时性死区
let声明的变量不会在作用域中被提升。解析代码时，JavaScript引擎会注意到出现在块后面的let声明，不过在此之前不能引用任何未声明的变量，在let声明之前的执行瞬间被称作"暂时性死区"，此阶段引用任何后面才声明的变量，都会抛出ReferenceError。
#### 1.2.3全局声明
var在全局作用域声明的变量会成为window对象的属性，但是let在全局作用域声明的变量则不会成为window对象。但是，let声明仍是作用在全局作用域中，相应变量也会在页面的生命周期内存续，因此，为了避免syntaxError，必须确保页面不会重复声明同一个变量（参考1.2.1）。
#### 1.2.4条件声明
var关键字声明的变量作用域会被提升，let关键字声明变量作用域无法提升，而且let作用域范围是函数内部的块，因此无法通过条件语句判断之前是否声明过该变量，而且根据let定义，在无法判断是否已经用let声明过变量情况下，再使用let声明变量可能会导致sytaxError。所以，对于let关键字不能对其依赖条件声明模式。
#### 1.2.5for循环中的let声明
var是全局作用域，有变量提升的作用，所以在for中定义一个变量，全局可以使用，循环中的每一次给变量i赋值都是给全局变量i赋值。
在for语句中，使用var和let声明关键字，其内部函数输出结果不同，原因在于var声明的变量会自动提升为全局变量，因此循环结束后的最终值为该全局变量的值，之后再执行内部循环逻辑函数；而使用let则会在内部循环块内，每次都为改改循环变量创建一个循环逻辑函数，这些函数变量不会相互干扰，因此会输出每个变量值。
```javascript    
    var a=[];
        for(var i=0;i<3;i++){
            a[i]= function(){
                console.log(i);
        }    
    }
    for语句解析为：
    {
        var i=0;
        if(0<3){
            a[0]=function(){
               console.log(i);
            }
        };
        i++;//i=1
        if(1<3){
            a[1]=function(){
                console.log(i);
             }
        };
        i++;//i=2
        if(2<3){
            a[2]=function(){
                console.log(i);
             }
        };
        i++;//i=3
        //a[0]开始执行i=0,直到要跳出函数时i=3，因此，console.log(i)执行结果为3。
    }    
    a[0]//3
    a[1]//3
    a[2]//3
    当用let替换var声明for语句条件时：
    for(let i=0;i<3;i++){
        a[i]=function(){
            console.log(i);
        }
    }
    for语句解析为：
    {
        let i=0;
        if(0<3){
            let j=i;
            a[j]=function(){
                console.log(j);
             }
         };
         i++;//i=1
         if(1<3){
            let j=i;
            a[j]=function(){
                console.log(j);
             }
         };
         i++;//i=2
         if(2<3){
            let j=i;
            a[j]=function(){
                console.log(j);
             }
         };
         i++//i=3
         //跳出循环，因为let声明变量为块作用域，因此三个函数的变量j都是各自块内的独立的变量，互不干扰。
    }
```